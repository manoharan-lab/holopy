.. _calc_tutorial:

=======================
Scattering Calculations
=======================

Optical physicists and astronomers have worked out how to compute the
scattering of light from many kinds of objects.  HoloPy provides an
easy interface for computing scattered fields, intensities, scattering
matrices, cross-sections, and holograms generated by microscopic objects.

Scattering calculations generally consist of the following steps:

1. Define a scatterer using a :mod:`~holopy.scattering.scatterer` object.

2. Specify laser properties and where to compute the values using a
   :mod:`~holopy.core.marray.Schema` object.

3. Use a calc function from a :mod:`~holopy.scattering.theory` object
   to compute scattered quantities.

A Simple Example
================

Let's start by calculating an in-line hologram generated by a
plane wave scattering from a microsphere.

.. plot:: pyplots/calc_sphere.py
   :include-source:


We'll examine each section of code in turn.  The first few lines :

..  testcode::
  
  import holopy as hp
  from holopy.scattering.scatterer import Sphere
  from holopy.core import ImageSchema, Optics
  from holopy.scattering.theory import Mie

load the relevant modules from HoloPy that we'll need for doing our
calculation.  The next line :

..  testcode::

  sphere = Sphere(n = 1.59+.0001j, r = .5, center = (4, 4, 5)) 

defines a :mod:`~holopy.scattering.scatterer` object, specifically a
:class:`.Sphere`. A :mod:`~holopy.scattering.scatterer` object
contains information about the geometry (position, size, shape) and
optical properties (refractive index) of the thing that is scattering
light.  Here, we've defined a spherical scatterer with radius 0.5,
center of mass at x=4, y=3, z=5 microns, and index of refraction
1.59+0.0001j. This refractive index is approximately that of
polystyrene. We include a small imaginary component (the "0.0001j") in
the refractive index because it helps avoid some numerical problems in
the scattering calculations. It won't significantly affect our
calculation.

For more on the types of scatterers you can model, see
:mod:`holopy.scattering.scatterer` or :ref:`more_scattering_ex`
below.

The next few lines define a :class:`~.Schema`:

..  testcode::

  schema = ImageSchema(shape = 100, spacing = .1,
                       optics = Optics(wavelen = .660, index = 1.33,
                                       polarization = [1,0]))

:class:`~.Schema` objects tell HoloPy what its calculated results
should look like. In general you might use them to model a particular
detector. Here we use a subclass of :class:`~.Schema` called an
:class:`.ImageSchema` to model a camera with 100x100 pixels (its
"shape") and a pixel size ("spacing") of 0.1 microns.

Schemas are (intentionally) similar to the objects created by loading
data.  For example, the :class:`.ImageSchema` object we've created
also contains metadata about the optical train, specifically, the
wavelength (in vacuum) and polarization of the incident light, and the
refractive index of the medium the scatterer is embedded in (see
:ref:`units` and :ref:`coordinate_system` if you're confused about how
the units and polarization are specified).  The metadata allows HoloPy
to calculate a hologram based solely on a Schema and a Scatterer.
That's what we'll do next.

.. note::
  
  An :class:`.ImageSchema` is similar to an :class:`.Image` object in
  that it specifies the coordinates of the camera pixels and contains
  the same optical information. The two object classes differ in that
  an :class:`.Image` must contain data for all of the coordinates,
  while an :class:`.ImageSchema` contains only the locations. So,
  Holopy allows you to provide an :class:`.Image` anywhere an
  :class:`.ImageSchema` is needed.  This comes in handy when fitting to
  an :class:`.Image` you have already loaded.

If you want to model other kinds of detectors, you can specify all of
the measurement locations using a general :class:`.Schema` object or
one of its other subclasses.

OK, now for the fun part. :

..  testcode::

  holo = Mie.calc_holo(sphere, schema) 

..  testcode::
    :hide:
    
    print(holo[0,0])

..  testoutput::
    :hide:

    1.0120388294

This line calculates the hologram using a scattering
:mod:`~holopy.scattering.theory`.  HoloPy contains a number of
scattering theories to model the scattering from different kinds of
scatterers.  Here, we've selected the Mie theory
(:class:`holopy.scattering.theory.mie`), which is the exact solution
to Maxwell's equations for the scattered field from a spherical
particle, originally derived by Gustav Mie and (independently) by
Ludvig Lorenz in the early 1900s. 

The ``Mie.calc_holo`` function will calculate the in-line hologram
generated at the detector plane by the interference between the
scattered field and the reference wave, which, for an in-line
hologram, is simply the part of the field that is not scattered 
or absorbed by the particle.  

You can visualize the hologram by running ::

  hp.show(holo)


You can also calculate just the scattered field using
``Mie.calc_field``, or the scattered intensity using
``Mie.calc_intensity``.  The scattered intensity is what is typically
measured in a light scattering experiment, whereas the hologram is
what you get when you put a camera very close to the particle and use
coherent illumination (a laser).

The Mie theory works nicely for spheres, but we wouldn't want to use
it for, say, a coffee cup.  HoloPy includes a number of different
scattering theories that are suited for different kinds of scatterers.
Have a look at the documentation for the
:mod:`holopy.scattering.theory` module to see what kinds of theories
you can use, and what scatterers they are useful for.  A
:mod:`~holopy.scattering.theory` will give an error if you try to use
it on an object for which it's not suitable.

.. _more_scattering_ex:

More Scattering Examples
========================

Now let's take these calculations a step further.  We'll compute the
scattering from objects more complex than a single sphere, and we'll
model other types of experiments and detectors.

Collection of Spheres
---------------------

Calculating a hologram from a collection of spheres is done in a very
similar manner to calculating a hologram from a single sphere

.. plot:: pyplots/calc_two_spheres.py
   :include-source: 

Note that the thing we're scattering from is now an object of type
:class:`.Spheres`, which is composed of multiple
:class:`.Sphere` objects.  This is why we
added the line :

..  testcode::
    :hide:
    
    from holopy.scattering.scatterer import Spheres
    s1=Sphere(center=(5,5,5), n=1.59,r=.5)
    s2=sphere

..  testcode::

  cluster = Spheres([s1, s2])

Using the Mie theory will calculate the hologram by superposing the
fields from multiple independent particles. This doesn't account for
multiple scattering or coupling of the near-fields of the particles.
If you want to include these effects, you should use the
:class:`~holopy.scattering.theory.multisphere` theory, based on the
SCSMFO package from Daniel Mackowski, which gives the exact solution to
Maxwell's equation for the scattering from an arbitrary arrangement of
non-overlapping spheres:

..  testcode::

    from holopy.scattering.theory import Multisphere
    holo = Multisphere.calc_holo(cluster, schema)

..  testcode::
    :hide:

    print(holo[0,0])

..  testoutput::
    :hide:

    1.04899645413

Adding more spheres to the cluster is as simple as defining more
sphere objects and passing a longer list of spheres to the
:class:`.Spheres` constructor.


Coated Spheres
--------------

Coated (or multilayered) spheres can use the same Mie theory as simple
spheres. Constructing a coated spheres differs only in specifying a
list of refractive indices and radii corresponding to the layers 
(starting from the core and working outwards).

.. plot:: pyplots/calc_coated_sphere.py
   :include-source:

  
Additionally, you can use Mie superposition for multiple spheres each
with multiple layers:

..  testcode::

  import holopy as hp
  from holopy.scattering.scatterer import Sphere, Spheres
  from holopy.scattering.theory import Mie
  from holopy.core import ImageSchema, Optics
  schema = ImageSchema(shape = 100, spacing = .1,
                       optics = Optics(wavelen = .660, index = 1.33,
                                       polarization = [1,0]))
  cs1 = Sphere(center=(8, 8, 15), n = (1.59, 1.42), \
               r = (0.3, 0.6))
  cs2 = Sphere(center=(2.5, 2, 12), n = (1.59, 1.33, 1.59),\
               r = (0.3, 0.6, .9))
  cs3 = Sphere(center=(2, 7, 14), n = (1.33, 1.59, 1.34),\
               r = (0.3, 0.6, .9))
  coatedspheres = Spheres([cs1,cs2,cs3])
  holo = Mie.calc_holo(coatedspheres, schema)

..  testcode::
    :hide:
    
    print(holo[0,0])

..  testoutput::
    :hide:
    
    1.32200295373

.. note::
        The multisphere theory does not yet work with coated spheres.

Ellipsoids
----------

You can calculate a hologram of an ellipsoid by using the discrete
dipole approximation (DDA). This requires first installing `ADDA
<http://code.google.com/p/a-dda/>`_.    ::

  import holopy as hp
  from holopy.scattering.theory import DDA
  from holopy.scattering.scatterer import Ellipsoid
  from holopy.core import ImageSchema, Optics

  e = Ellipsoid(1.5, r = (.5, .1, .1), center = (1, 2, 10))

  schema = ImageSchema(shape = 100, spacing = .1,
                       optics = Optics(wavelen = .660, index = 1.33,
                                       polarization = [1,0]))
  h = DDA.calc_holo(e, schema)

..  THE ABOVE CODE IS NOT CURRENTLY TESTED

Non-Square Detectors and/or Pixels
----------------------------------

The holograms above make use of several default assumptions.  When you
make an ImageSchema like ::

  schema = ImageSchema(shape = 100, spacing = .1...)

you are making HoloPy assume a square array of evenly spaced grid
points. You could have written the same instructions explicitly as: ::

  schema = ImageSchema(shape = (100, 100), spacing = (.1, .1)...)
  
If you wanted a rectangular detector with rectangular pixels, you
could specify that as: ::

  schema = ImageSchema(spacing = (.1,.2), shape = (400,300), 
                       optics = Optics(wavelen = .660, index = 1.33,
                                       polarization = [1,0]))

Most displays will default to displaying square pixels, but if your
hologram has an associated spacing (holo.spacing), and you use
holopy.show(holo) to display the image, your hologram will display
with pixels of the correct aspect ratio.

.. _scattering_matrices:

Static light scattering calculations 
-------------------------------------

In a static light scattering measurement you record the scattered
intensity at a number of angles.  In this kind of experiment you are
usually not interested in the exact distance of the detector from the
particles, and so it's most convenient to work with scattering matrices. 

.. plot:: pyplots/calc_scat_matr.py
   :include-source:

..  THE ABOVE CODE IS NOT CURRENTLY TESTED  

Here we omit specifying the location (center) of the scatterer.  This is
only valid when you're calculating a far-field quantity.

Non-default Theory Parameters
-----------------------------

.. TODO Mac compatibility for Multisphere() and multi.calc_holo()

Some theories like
:class:`~holopy.scattering.theory.multisphere.Multisphere` have
adjustable parameters that relate to numerical tolerances.  In general
our defaults will work fine, but you can adjust them by instantiating
the theory and calling calc functions on that specific object.  

..  testcode::

  import holopy as hp
  from holopy.core import ImageSchema, Optics
  from holopy.scattering.scatterer import Sphere, Spheres
  from holopy.scattering.theory import Multisphere
  s1 = Sphere(center=(5, 5, 5), n = 1.59, r = 0.5)
  s2 = Sphere(center=(4, 4, 5), n = 1.59, r = 0.5)
  cluster = Spheres([s1, s2])
  schema = ImageSchema(shape = 100, spacing = .1, 
    optics = Optics(wavelen = .660, polarization = [0,1], \
                    index = 1.33))
  multi = Multisphere(niter = 100)
  holo = multi.calc_holo(cluster, schema)

..  testcode::
    :hide:

    print(holo[0,0])

..  testoutput::
    :hide:

    1.04897654596

Here we adjusted the maximum number of iterations (``niter``) used in
converging the multisphere solution.

