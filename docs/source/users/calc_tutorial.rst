.. _calc_tutorial:

=======================
Scattering Calculations
=======================

Optical physicists and astronomers have worked out how to compute the
scattering of light from many kinds of objects.  HoloPy provides an
easy interface for computing scattered fields, intensities, scattering
matrices, cross-sections, and holograms generated by microscopic objects.


A Simple Example
================

Let's start by calculating an in-line hologram generated by a
plane wave scattering from a microsphere.

.. plot:: pyplots/calc_sphere.py
   :include-source:


We'll examine each section of code in turn.  The first few lines :

..  testcode::
  
    import holopy as hp
    from holopy.core import ImageSchema
    from holopy.scattering import calc_holo, Sphere

load the relevant modules from HoloPy that we'll need for doing our
calculation.  The next block:

..  testcode::

    wavelen = 0.66
    polarization = (1, 0)
    index = 1.33
    schema = ImageSchema(shape = 100, spacing = .1, index = index, wavelen = wavelen, polarization = polarization)

describes the scattering setup we would like to simulate. 
We are going to be using red light (wavelength = 660 nm in vacuum) polarized in the x-direction to 
illuminate a scatterer immersed in water (refractive index = 1.33). Refer to 
:ref:`units` and :ref:`coordinate_system` if you're confused about how
the wavelength and polarization are specified. The information about illumination gets packaged into 
an :class:`.ImageSchema` object that also includes information about our detector. Specifically, we 
describe a 100 x 100 pixel array, with each square pixel of side length .1 microns. You can think of the schema
as a description of everything that goes into a scattering experiment besides the scatterer itself.

..  note::
   
    :class:`.ImageSchema` is a subclass of :class:`.Schema` that describes a set of measurement points in a rectangular array.
    If you want to model other kinds of detectors, you can specify all of the measurement locations using a general Schema object or one of its other subclasses.   

Now that we have described our scattering setup, we are ready to describe our scatterer:

..  testcode::

    sphere = Sphere(n = 1.59, r = .5, center = (4, 4, 5)) 
   
Here we have defined a :mod:`~holopy.scattering.scatterer` object, specifically a
:class:`.Sphere`. A :mod:`~holopy.scattering.scatterer` object
contains information about the geometry (position, size, shape) and
optical properties (refractive index) of the object that is scattering
light.  Here, we've defined a spherical scatterer with radius 0.5 microns,
center of mass at x=4, y=4, z=5 microns, and index of refraction
1.59. This refractive index is approximately that of
polystyrene.

After setting everything up, the actual scattering calculation is straightforward:

..  testcode::

    holo = calc_holo(schema, sphere)
    hp.show(holo)

Congratulations! You just calculated the in-line hologram
generated at the detector plane by interference between the
scattered field and the reference wave, which, for an in-line
hologram, is simply the part of the field that is not scattered 
or absorbed by the particle.  

..  testcode::
    :hide:
    
    print(holo[0,0])

..  testoutput::
    :hide:

    1.01201781778

You might have noticed that our schema object has much of the same metadata we specified when loading an image.
If we have an image from the scattering experiment we would like to model, we can use that in ``calc_holo()`` instead of a schema.
HoloPy will then use the experimental image's metadata to calculate a hologram image with the same dimensions. This
can be very useful when comparing predicted holograms to measured data.

As with propagating images, we also have the option to specify optical parameters directly when calling the function.
In this case, we can specify a schema that includes spatial information about the detector, or we can just list a set of positions at which to record data.
For example, to define an array of measurement points in the z = 0 plane:

..  testcode::
    
    import numpy as np
    locations = [[(i, j, 0) for i in np.linspace(0, 10, 100)] for j in np.linspace(0, 10, 100)]
    holo = calc_holo(locations, sphere, index, wavelen, polarization)
    hp.show(holo)

..  testcode::
    :hide:
    
    print(holo[0,0])

..  testoutput::
    :hide:

    1.01201781778

So far the images we have calculated are all holograms, or the interference pattern that results
from the superposition of a scattered wave with a reference wave. Holopy can also be used to
examine scattered fields on their own. Simply replace ``calc_holo`` with ``calc_field`` to look 
at scattered electric fields (complex) or ``calc_intensity`` to look at field amplitudes, which
is the typical measurement in a light scattering experiment.


.. _more_scattering_ex:

More Scattering Examples
========================

Coated Spheres
--------------

HoloPy can also calculate holograms from coated (or multilayered) spheres.
Constructing a coated sphere differs only in specifying a
list of refractive indices and radii corresponding to the layers 
(starting from the core and working outwards).

..  testcode::
    
    coated_sphere = Sphere(center=(2.5, 5, 5), n=(1.59, 1.42), r=(0.3, 0.6))
    holo = calc_holo(schema, coated_sphere)
    hp.show(holo)

..  testcode::
    :hide:

    print(holo[0,0])

..  testoutput::
    :hide:

    0.975060855373    
    
..  plot:: pyplots/calc_coated_sphere.py


Collection of Spheres
---------------------

If we want to calculate a hologram from a collection of spheres, we must
first define the spheres individually, and then combine them into a 
:class:`.Spheres` object:

..  testcode::

    from holopy.scattering import Spheres
    s1 = Sphere(center=(5, 5, 5), n = 1.59, r = .5)
    s2 = Sphere(center=(4, 4, 5), n = 1.59, r = .5)
    collection = Spheres([s1, s2])
    holo = calc_holo(schema, collection)
    hp.show(holo)

..  testcode::
    :hide:

    print(holo[0,0])

..  testoutput::
    :hide:

    1.04897654596

.. plot:: pyplots/calc_two_spheres.py

Adding more spheres to the cluster is as simple as defining more
sphere objects and passing a longer list of spheres to the
:class:`.Spheres` constructor.


Scattering Theories in HoloPy
-----------------------------
    
HoloPy contains a number of scattering theories to model the scattering 
from different kinds of scatterers. By default, scattering from single
spheres is calculated using Mie theory, which is the exact solution
to Maxwell's equations for the scattered field from a spherical
particle, originally derived by Gustav Mie and (independently) by
Ludvig Lorenz in the early 1900s. 

A scatterer composed of multiple spheres can exhibit multiple scattering 
and coupling of the near-fields of the particles. Mie theory doesn't include
these effects, so :class:`.Spheres` objects are by default calculated using the
SCSMFO package from Daniel Mackowski, which gives the exact solution to
Maxwell's equation for the scattering from an arbitrary arrangement of
non-overlapping spheres. 

Sometimes you might want to calculate scattering from multiple spheres 
using Mie theory if you are worried about computation time or if you are
using multi-layered spheres (HoloPy's implementation of the multisphere theory
can't currently handle coated spheres). You can specify Mie theory manually when
calling the `calc_holo` function:

..  testcode::
    
    from holopy.scattering import Mie
    holo = calc_holo(schema, collection, theory=Mie)

Holopy can also access a discrete dipole approximation (DDA) theory to model arbitrary
non-spherical objects. See the :ref:`dda_tutorial` tutorial for more details.

.. _scattering_matrices:

Static light scattering calculations 
-------------------------------------

In a static light scattering measurement you record the scattered
intensity at a number of angles. In this kind of experiment you are
usually not interested in the exact distance of the detector from the
particles, and so it's most convenient to work with scattering matrices. 

..  testcode::

    from holopy.core import Angles
    from holopy.scattering import calc_scat_matrix
    
    angle_list = Angles(np.linspace(0, np.pi, 100))
    distant_sphere = Sphere(r=0.5, n=1.59)
    matr = calc_scat_matrix(angle_list, distant_sphere, index, wavelen)
    
..  testcode::
    :hide:
    
    print(matr[0,0,0])

..  testoutput::
    :hide:

    (24.65695042-19.7655277886j)

Here we omit specifying the location (center) of the scatterer. This is
only valid when you're calculating a far-field quantity. Similarly, note 
that we defined measurement positions in terms of an :class:`.Angles` object,
which includes information about direction but not distance. It is typical 
to look at scattering matrices on a semilog plot. You can make one as follows:
    
..  testcode::

    import matplotlib.pyplot as plt
    plt.figure()
    plt.semilogy(np.linspace(0, np.pi, 100), abs(matr[:,0,0])**2)
    plt.semilogy(np.linspace(0, np.pi, 100), abs(matr[:,1,1])**2)
    plt.show()

.. plot:: pyplots/calc_scat_matr.py

The scattering cross section provides a measure of how much light from an incident 
beam is scattered by a particular scatterer. Similar to calculating scattering matrices,
we can omit the position of the scatterer for calculation of cross sections.
Since cross sections integrates over all angles, we can also omit the 
:class:`.Schema` or `positions` argument entirely:

..  testcode::

    from holopy.scattering import calc_cross_sections
    x_sec = calc_cross_sections(distant_sphere, index, wavelen, polarization)
    
..  testcode::
    :hide:

    print(x_sec[0])

..  testoutput::
    :hide:

    1.93274288711

x_sec returns an array containing four elements. The first element is the scattering cross section, specified in terms of the same
units as wavelength and particle size. The second and third elements are the absorption
and extinction cross sections, respectively. The final element is the average value of the cosine of the scattering angle.




